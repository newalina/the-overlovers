<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <meta name="author" content="newalina" />
    <title>skin and bone</title>
    <link rel="icon" href="/assets/symbols/icon.png" />
    <link rel="stylesheet" href="/style.css" />
    <script
      src="https://kit.fontawesome.com/b7a6c98a66.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="container">
      <main>
        <div id="anchor-container">
          <a id="header" href="../">
            <img
              src="/assets/symbols/symbol black.png"
              alt="symbol black"
              class="symbol"
            />
          </a>
        </div>
        <div id="anchor-container">
          <div id="lyrics">
            <div id="lyrics-7">
              Out of sight<br />
              Out of mind<br />
              Dear my light<br />
              Burn the night<br /><br />

              Sweet curious loving life<br />
              Wanting what they cannot have<br />
              Nobody was ever hurt<br />
              You’re my wishing star<br /><br />

              Be alright<br />
              Kiss your wife<br />
              Say goodbye<br />
              Twist the knife<br /><br />

              Sweet curious loving life<br />
              Wanting what they cannot have<br />
              Nobody was ever hurt<br />
              You’re my wishing<br />

              ...<br /><br />

              I loved forgiving you<br />
              I loved forgetting you<br />
              I loved becoming you<br />
              I loved loving you<br /><br />

              Close your eyes and count stars<br />
              Close your eyes and count skies<br />
              Close your eyes and count yourself<br />
              Close your eyes and count with me<br /><br />

              One two three four one two three<br />
              Two two three four one two three<br />
              Three two three four one two three<br />
              Four two three four one two three
            </div>
          </div>
        </div>
        <a class="arrow left-arrow" href="/firstdayinheaven">
          <div class="arrow-top"></div>
          <div class="arrow-bottom"></div>
        </a>
        <a class="arrow right-arrow" href="/if">
          <div class="arrow-top"></div>
          <div class="arrow-bottom"></div>
        </a>
        <div id="anchor-container">
          <div id="footer">
            <a href="https://www.instagram.com/theoverlovers" target="_blank">
              <i class="icon fa-brands fa-square-instagram fa-xl"></i>
            </a>
            <a
              href="https://open.spotify.com/album/7KUdKTrrTqQCnqXHqZALP3"
              target="_blank"
            >
              <i class="icon fa-brands fa-spotify fa-xl"></i>
            </a>
            <a
              href="https://music.apple.com/us/album/sensibilities/1700245072"
              target="_blank"
            >
              <i class="icon fa-solid fa-music fa-xl"></i>
            </a>
            <a
              href="https://music.youtube.com/playlist?list=OLAK5uy_n8Xm-bF0nlln5ZT--a3riHbIh4aljUM7c"
              target="_blank"
            >
              <i class="icon fa-brands fa-youtube fa-xl"></i>
            </a>
          </div>
        </div>
      </main>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
          "three/nodes": "https://unpkg.com/three@0.158.0/examples/jsm/nodes/Nodes.js",
          "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import {
        tslFn,
        texture,
        uv,
        uint,
        positionWorld,
        modelWorldMatrix,
        cameraViewMatrix,
        timerLocal,
        timerDelta,
        cameraProjectionMatrix,
        vec2,
        instanceIndex,
        positionGeometry,
        storage,
        MeshBasicNodeMaterial,
        If,
      } from "three/nodes";

      import WebGPU from "three/addons/capabilities/WebGPU.js";
      import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";

      const maxParticleCount = 8400;
      const instanceCount = maxParticleCount / 2;

      let camera, scene, renderer;
      let controls;
      let computeParticles;
      let clock;

      let collisionBox, collisionCamera, collisionPosRT, collisionPosMaterial;

      init();

      function init() {
        const { innerWidth, innerHeight } = window;

        camera = new THREE.PerspectiveCamera(
          60,
          innerWidth / innerHeight,
          0.1,
          110
        );
        camera.position.set(0.1, -60, 0);
        camera.lookAt(0, 0, 0);

        const listener = new THREE.AudioListener();
        camera.add(listener);

        const sound = new THREE.Audio(listener);

        const audioLoader = new THREE.AudioLoader();
        audioLoader.load("/assets/songs/skin and bone.mp3", function (buffer) {
          sound.setBuffer(buffer);
          sound.setLoop(true);
          sound.play();
        });

        scene = new THREE.Scene();

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.castShadow = true;
        dirLight.position.set(3, 12, 17);
        dirLight.castShadow = true;
        dirLight.shadow.camera.near = 5;
        dirLight.shadow.camera.far = 50;
        dirLight.shadow.camera.right = 10;
        dirLight.shadow.camera.left = -10;
        dirLight.shadow.camera.top = 10;
        dirLight.shadow.camera.bottom = -10;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.01;

        scene.add(dirLight);
        scene.add(new THREE.AmbientLight(0x111111));

        collisionCamera = new THREE.OrthographicCamera(
          -50,
          50,
          50,
          -50,
          0.1,
          50
        );
        collisionCamera.position.y = 50;
        collisionCamera.lookAt(0, 0, 0);
        collisionCamera.layers.disableAll();
        collisionCamera.layers.enable(1);

        collisionPosRT = new THREE.RenderTarget(1024, 1024);
        collisionPosRT.texture.type = THREE.HalfFloatType;

        collisionPosMaterial = new MeshBasicNodeMaterial();
        collisionPosMaterial.colorNode = positionWorld;

        const createBuffer = (type = "vec3") =>
          storage(
            new THREE.InstancedBufferAttribute(
              new Float32Array(maxParticleCount * 4),
              4
            ),
            type,
            maxParticleCount
          );

        const positionBuffer = createBuffer();
        const velocityBuffer = createBuffer();
        const ripplePositionBuffer = createBuffer();
        const rippleTimeBuffer = createBuffer();

        const timer = timerLocal();

        const randUint = () => uint(Math.random() * 0xffffff);

        const computeInit = tslFn(() => {
          const position = positionBuffer.element(instanceIndex);
          const velocity = velocityBuffer.element(instanceIndex);
          const rippleTime = rippleTimeBuffer.element(instanceIndex);

          const randX = instanceIndex.hash();
          const randY = instanceIndex.add(randUint()).hash();
          const randZ = instanceIndex.add(randUint()).hash();

          position.x = randX.mul(100).add(-50);
          position.y = randY.mul(25);
          position.z = randZ.mul(100).add(-50);

          velocity.y = randX.mul(-0.04).add(-0.2);

          rippleTime.x = 1000;
        })().compute(maxParticleCount);

        const computeUpdate = tslFn(() => {
          const getCoord = (pos) => pos.add(50).div(100);

          const position = positionBuffer.element(instanceIndex);
          const velocity = velocityBuffer.element(instanceIndex);
          const ripplePosition = ripplePositionBuffer.element(instanceIndex);
          const rippleTime = rippleTimeBuffer.element(instanceIndex);

          position.addAssign(velocity);

          rippleTime.x = rippleTime.x.add(timerDelta().mul(4));

          const collisionArea = texture(
            collisionPosRT.texture,
            getCoord(position.xz)
          );

          const surfaceOffset = 0.05;

          const floorPosition = collisionArea.y.add(surfaceOffset);

          const ripplePivotOffsetY = -0.9;

          If(position.y.add(ripplePivotOffsetY).lessThan(floorPosition), () => {
            position.y = 25;

            ripplePosition.x = position.x;
            ripplePosition.y = floorPosition;
            ripplePosition.z = position.z;

            rippleTime.x = 1;

            position.x = instanceIndex.add(timer).hash().mul(100).add(-50);
            position.z = instanceIndex
              .add(timer.add(randUint()))
              .hash()
              .mul(100)
              .add(-50);
          });

          const rippleOnSurface = texture(
            collisionPosRT.texture,
            getCoord(ripplePosition.xz)
          );

          const rippleFloorArea = rippleOnSurface.y.add(surfaceOffset);

          If(ripplePosition.y.greaterThan(rippleFloorArea), () => {
            rippleTime.x = 1000;
          });
        });

        computeParticles = computeUpdate().compute(maxParticleCount);

        const billboarding = tslFn(() => {
          const particlePosition = positionBuffer.toAttribute();

          const worldMatrix = modelWorldMatrix.toVar();
          worldMatrix[3][0] = particlePosition.x;
          worldMatrix[3][1] = particlePosition.y;
          worldMatrix[3][2] = particlePosition.z;

          const modelViewMatrix = cameraViewMatrix.mul(worldMatrix);
          modelViewMatrix[0][0] = 1;
          modelViewMatrix[0][1] = 0;
          modelViewMatrix[0][2] = 0;

          modelViewMatrix[2][0] = 0;
          modelViewMatrix[2][1] = 0;
          modelViewMatrix[2][2] = 1;

          return cameraProjectionMatrix
            .mul(modelViewMatrix)
            .mul(positionGeometry);
        });

        const rainMaterial = new MeshBasicNodeMaterial();
        rainMaterial.colorNode = uv()
          .distance(vec2(0.5, 0))
          .oneMinus()
          .mul(3)
          .exp()
          .mul(0.1);
        rainMaterial.vertexNode = billboarding();
        rainMaterial.opacity = 0.2;
        rainMaterial.side = THREE.DoubleSide;
        rainMaterial.forceSinglePass = true;
        rainMaterial.depthWrite = false;
        rainMaterial.depthTest = true;
        rainMaterial.transparent = true;

        const rainParticles = new THREE.Mesh(
          new THREE.PlaneGeometry(0.1, 2),
          rainMaterial
        );
        rainParticles.isInstancedMesh = true;
        rainParticles.count = instanceCount;
        scene.add(rainParticles);

        const rippleTime = rippleTimeBuffer.element(instanceIndex).x;

        const rippleEffect = tslFn(() => {
          const center = uv().add(vec2(-0.5)).length().mul(7);
          const distance = rippleTime.sub(center);

          return distance.min(1).sub(distance.max(1).sub(1));
        });

        const rippleMaterial = new MeshBasicNodeMaterial();
        rippleMaterial.colorNode = rippleEffect();
        rippleMaterial.positionNode = positionGeometry.add(
          ripplePositionBuffer.toAttribute()
        );
        rippleMaterial.opacityNode = rippleTime
          .mul(0.3)
          .oneMinus()
          .max(0)
          .mul(0.5);
        rippleMaterial.side = THREE.DoubleSide;
        rippleMaterial.forceSinglePass = true;
        rippleMaterial.depthWrite = false;
        rippleMaterial.depthTest = true;
        rippleMaterial.transparent = true;

        const surfaceRippleGeometry = new THREE.PlaneGeometry(2.5, 2.5);
        surfaceRippleGeometry.rotateX(-Math.PI / 2);

        const xRippleGeometry = new THREE.PlaneGeometry(1, 2);
        xRippleGeometry.rotateY(-Math.PI / 2);

        const zRippleGeometry = new THREE.PlaneGeometry(1, 2);

        const rippleGeometry = BufferGeometryUtils.mergeGeometries([
          surfaceRippleGeometry,
          xRippleGeometry,
          zRippleGeometry,
        ]);

        const rippleParticles = new THREE.Mesh(rippleGeometry, rippleMaterial);
        rippleParticles.isInstancedMesh = true;
        rippleParticles.count = instanceCount;
        scene.add(rippleParticles);

        const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
        floorGeometry.rotateX(-Math.PI / 2);

        const plane = new THREE.Mesh(
          floorGeometry,
          new THREE.MeshBasicMaterial({ color: 0x050505 })
        );
        scene.add(plane);

        collisionBox = new THREE.Mesh(
          new THREE.BoxGeometry(30, 1, 15),
          new THREE.MeshStandardMaterial()
        );
        collisionBox.material.color.set(0x333333);
        collisionBox.position.y = 12;
        collisionBox.scale.x = 3.5;
        collisionBox.layers.enable(1);
        collisionBox.castShadow = true;
        scene.add(collisionBox);

        clock = new THREE.Clock();

        renderer = new WebGPURenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        document.body.appendChild(renderer.domElement);

        renderer.compute(computeInit);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.update();

        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        const { innerWidth, innerHeight } = window;

        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(innerWidth, innerHeight);
      }

      function animate() {
        scene.overrideMaterial = collisionPosMaterial;
        renderer.setRenderTarget(collisionPosRT);
        renderer.render(scene, collisionCamera);

        renderer.compute(computeParticles);

        scene.overrideMaterial = null;
        renderer.setRenderTarget(null);
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
